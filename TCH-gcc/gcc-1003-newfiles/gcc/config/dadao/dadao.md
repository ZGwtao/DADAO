;; vim: filetype=lisp

;; GCC machine description for DADAO
;; Copyright (C) 2020-2033 Guan Xuetao (AT) Peking Univ.
;; Contributed by Guan Xuetao <gxt@pku.edu.cn>

;; The original PO technology requires these to be ordered by speed,
;; so that assigner will pick the fastest.

(define_constants
	[(DD_RA_REG		126)]
)

(include "iterators.md")
(include "predicates.md")
(include "constraints.md")

(include "dadao-rg.md")
(include "dadao-rp.md")
(include "dadao-rf.md")
(include "dadao-rr.md")
(include "dadao-cc.md")

(define_insn "nop"
  [(const_int 0)]
	""
	"swym")

;; TODO: are there rp2rf, rf2rv, rv2rs, ... requirements?
(define_insn "mov<mode>"
  [(set (match_operand:QHSD 0 "register_operand" "= Rg")
        (match_operand:QHSD 1 "register_operand" "  Rg"))]
	""
	"or	%0, %1, 0")

(define_insn "dd_ld_<mode>"
  [(set (match_operand:QHSD 0 "rg_class_operand" "= Rg")
        (match_operand:QHSD 1 "memory_operand"   "   m"))]
	""
	"ld<bwto>	%0, %1")

(define_insn "dd_st_<mode>"
  [(set (match_operand:QHSD 0 "memory_operand"   "=  m")
        (match_operand:QHSD 1 "rg_class_operand" "  Rg"))]
	""
	"st<bwto>	%1, %0")

;; TODO: hope following insns will be optimized during rtl process
(define_insn "*dd_st_2_<mode>"
  [(set (match_operand:QHSD 0 "memory_operand" "")
        (match_operand:QHSD 1 "general_operand" ""))]
	""
	"")

(define_expand "call"
  [(parallel [(call (match_operand 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (use  (match_operand 2 "" ""))
	      (clobber (reg:DI DD_RA_REG))])]
	""
{
	/* The caller checks that the operand is generally valid as an
	   address, but at -O0 nothing makes sure that it's also a valid
	   call address for a *call*; a dadao_symbolic_or_address_operand.
	   Force into a register if it isn't.  */
	if (!dadao_symbolic_or_address_operand (XEXP (operands[0], 0),
				GET_MODE (XEXP (operands[0], 0))))
	operands[0] = replace_equiv_address (operands[0],
				force_reg (Pmode, XEXP (operands[0], 0)));

	/* FIXME: There's a bug in gcc which causes NULL to be passed as
	   operand[2] when we get out of registers, which later confuses gcc.
	   Work around it by replacing it with const_int 0.  Possibly documentation
	   error too.  */
	if (operands[2] == NULL_RTX)	operands[2] = const0_rtx;
})

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
		   (call (match_operand 1 "memory_operand" "")
			 (match_operand 2 "general_operand" "")))
	      (use (match_operand 3 "" ""))
	      (clobber (reg:DI DD_RA_REG))])]
	""
{
	/* The caller checks that the operand is generally valid as an
	   address, but at -O0 nothing makes sure that it's also a valid
	   call address for a *call*; a dadao_symbolic_or_address_operand.
	   Force into a register if it isn't.  */
	if (!dadao_symbolic_or_address_operand (XEXP (operands[1], 0),
				GET_MODE (XEXP (operands[1], 0))))
	operands[1] = replace_equiv_address (operands[1],
				force_reg (Pmode, XEXP (operands[1], 0)));

	/* FIXME: See 'call'.  */
	if (operands[3] == NULL_RTX)	operands[3] = const0_rtx;

	/* FIXME: Documentation bug: operands[3] (operands[2] for 'call') is the
	   *next* argument register, not the number of arguments in registers.
	   (There used to be code here where that mattered.)  */
})

;; Don't use 'p' here.  A 'p' must stand first in constraints, or reload
;; messes up, not registering the address for reload.  Several C++
;; testcases, including g++.brendan/crash40.C.  FIXME: This is arguably a
;; bug in gcc.  Note line ~2612 in reload.c, that does things on the
;; condition <<else if (constraints[i][0] == 'p')>> and the comment on
;; ~3017 that says:
;; <<   case 'p':
;;	     /* All necessary reloads for an address_operand
;;	        were handled in find_reloads_address.  */>>
;; Sorry, I have not dug deeper.  If symbolic addresses are used
;; rarely compared to addresses in registers, disparaging the
;; first ("p") alternative by adding ? in the first operand
;; might do the trick.  We define 'Au' as a synonym to 'p', but without the
;; caveats (and very small advantages) of 'p'.
;; As of r190682 still so: newlib/libc/stdlib/dtoa.c ICEs if "p" is used.
(define_insn "*call_real"
  [(call (mem:SI
	  (match_operand:DI 0 "dadao_symbolic_or_address_operand" "s,RpAu"))
	 (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (clobber (reg:DI DD_RA_REG))]
  ""
  "@
	call	%0
	call	%2, %a0")

(define_insn "*call_value_real"
  [(set (match_operand 0 "register_operand" "=r,r")
	(call (mem:SI
	       (match_operand:DI 1 "dadao_symbolic_or_address_operand" "s,RpAu"))
	      (match_operand 2 "" "")))
  (use (match_operand 3 "" ""))
  (clobber (reg:DI DD_RA_REG))]
  ""
  "@
	call	%1
	call	%3, %a1")

;; I hope untyped_call and untyped_return are not needed for DADAO.
;; Users of Objective-C will notice.

; Generated by GCC.
(define_expand "return"
  [(return)]
  "dadao_use_simple_return ()"
  "")

; Generated by the epilogue expander.
(define_insn "*expanded_return"
  [(return)]
  ""
	"ret")

(define_expand "prologue"
  [(const_int 0)]
  ""
  "dadao_expand_prologue (); DONE;")

; Note that the (return) from the expander itself is always the last insn
; in the epilogue.
(define_expand "epilogue"
  [(return)]
  ""
  "dadao_expand_epilogue ();")

(define_insn "jump"
  [(set (pc) (label_ref (match_operand 0 "" "")))]
  ""
	"jump	%0")

(define_insn "indirect_jump"
  [(set (pc) (match_operand 0 "address_operand" "p"))]
  ""
	"jump	rg63, %a0")

;; FIXME: This is just a jump, and should be expanded to one.
(define_insn "tablejump"
  [(set (pc) (match_operand:DI 0 "address_operand" "p"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
	"jump	rg63, %a0")
