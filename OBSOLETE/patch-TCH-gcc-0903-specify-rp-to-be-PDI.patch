diff --git a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/constraints.md b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/constraints.md
index c23c163..bc7be54 100644
--- a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/constraints.md
+++ b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/constraints.md
@@ -79,7 +79,10 @@
 (define_constraint "Ai"
 	"@internal"
 	(and (not (match_code "const_int,const_double"))
-	          (match_test "dadao_constant_address_p (op)")))
+	     (match_test "dadao_constant_address_p (op)")
+	     (ior (match_code "label_ref")
+	          (and (match_code "symbol_ref")
+		       (match_test "SYMBOL_REF_FLAG (op)")))))
 
 (define_address_constraint "Au"
 	"@internal"
diff --git a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-modes.def b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-modes.def
index 2816446..5a8c4b2 100644
--- a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-modes.def
+++ b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-modes.def
@@ -24,3 +24,6 @@ CC_MODE (CCUU);
 /* The CCFF mode is for a floating-point comparison using FTC/FOC insn.
    The result is 1 for true, 0 for false, otherwise -1. */
 CC_MODE (CCFF);
+
+/* PImode for 64-bit address pointers */
+PARTIAL_INT_MODE (DI, 48, PDI);
diff --git a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-rp.md b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-rp.md
index fad59a5..d20bde1 100644
--- a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-rp.md
+++ b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao-rp.md
@@ -4,10 +4,28 @@
 ;; Copyright (C) 2020-2033 Guan Xuetao (AT) Peking Univ.
 ;; Contributed by Guan Xuetao <gxt@pku.edu.cn>
 
+(define_insn "*mov_rp"
+  [(set (match_operand:PDI 0 "rp_class_operand" "= Rp")
+        (match_operand:PDI 1 "rp_class_operand" "  Rp"))]
+	""
+	"rp_p2p	%0, %1")
+
+(define_insn "*mov_rp_p2g"
+  [(set (match_operand:PDI 0 "rg_class_operand" "= Rg")
+        (match_operand:PDI 1 "rp_class_operand" "  Rp"))]
+	""
+	"rp_p2g	%0, %1")
+
+(define_insn "*mov_rp_g2p"
+  [(set (match_operand:PDI 0 "rp_class_operand" "= Rp")
+        (match_operand:PDI 1 "rg_class_operand" "  Rg"))]
+	""
+	"rp_g2p	%0, %1")
+
 (define_insn "*addrp"
-  [(set      (match_operand:DI 0 "rp_class_operand"  "= Rp, Rp")
-    (plus:DI (match_operand:DI 1 "rp_class_operand"  "% Rp, Rp")
-             (match_operand:DI 2 "dd_rg_s12_operand" "  Id, Rg")))]
+  [(set      (match_operand:PDI 0 "rp_class_operand"  "= Rp, Rp")
+    (plus:PDI (match_operand:PDI 1 "rp_class_operand"  "% Rp, Rp")
+             (match_operand:PDI 2 "dd_rg_s12_operand" "  Id, Rg")))]
 	""
 	"@
 	rp_add	%0, %1, %2
@@ -44,7 +62,7 @@
 ;; TODO: SHOULD removed lator
 (define_insn "*addrp2rg"
   [(set      (match_operand:DI 0 "rg_class_operand"  "= Rg, Rg")
-    (plus:DI (match_operand:DI 1 "rp_class_operand"  "% Rp, Rp")
+    (plus:DI (match_operand:PDI 1 "rp_class_operand"  "% Rp, Rp")
              (match_operand:DI 2 "dd_rg_s12_operand" "  Id, Rg")))]
 	""
 	"@
@@ -54,23 +72,23 @@
 ;; TODO: SHOULD removed lator, handling condition: imm beyond s12
 (define_insn "*addrp2rg_2"
   [(set      (match_operand:DI 0 "rg_class_operand"  "= Rg")
-    (plus:DI (match_operand:DI 1 "rp_class_operand"  "% Rp")
+    (plus:DI (match_operand:PDI 1 "rp_class_operand"  "% Rp")
              (match_operand:DI 2 "immediate_operand" "   i")))]
 	""
 	"rp_p2g	datao1, %1	\;	seto	%0, %2	\;	add	%0, datao1, %0")
 
 ;; TODO: SHOULD removed lator
 (define_insn "*addrp2rp"
-  [(set      (match_operand:DI 0 "rp_class_operand" "= Rp")
-    (plus:DI (match_operand:DI 1 "rp_class_operand" "%  0")
-             (match_operand:DI 2 "rp_class_operand" "  Rp")))]
+  [(set      (match_operand:PDI 0 "rp_class_operand" "= Rp")
+    (plus:PDI (match_operand:PDI 1 "rp_class_operand" "%  0")
+             (match_operand:PDI 2 "rp_class_operand" "  Rp")))]
 	""
 	"rp_p2g	datao1, %1	\;	rp_add	%0, %0, datao1")
 
 ;; TODO: SHOULD removed lator, handling condition: imm beyond s12
 (define_insn "*addrp2rp_2"
-  [(set      (match_operand:DI 0 "rp_class_operand"  "= Rp")
-    (plus:DI (match_operand:DI 1 "rp_class_operand"  "% Rp")
-             (match_operand:DI 2 "immediate_operand" "   i")))]
+  [(set      (match_operand:PDI 0 "rp_class_operand"  "= Rp")
+    (plus:PDI (match_operand:PDI 1 "rp_class_operand"  "% Rp")
+             (match_operand:PDI 2 "immediate_operand" "   i")))]
 	""
 	"seto	datao1, %2	\;	rp_add	%0, %1, datao1")
diff --git a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.c b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.c
index 782453c..047a5c7 100644
--- a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.c
+++ b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.c
@@ -148,7 +148,7 @@ static reg_class_t dd_secondary_reload (bool in_p ATTRIBUTE_UNUSED,
 		machine_mode reload_mode ATTRIBUTE_UNUSED,
 		secondary_reload_info *sri ATTRIBUTE_UNUSED)
 {
-	return NO_REGS;
+	return GENERAL_REGS;
 }
 
 #undef	TARGET_SECONDARY_RELOAD
@@ -157,6 +157,14 @@ static reg_class_t dd_secondary_reload (bool in_p ATTRIBUTE_UNUSED,
 #undef	TARGET_LRA_P
 #define	TARGET_LRA_P				hook_bool_void_false
 
+static reg_class_t dd_spill_class (reg_class_t rclass ATTRIBUTE_UNUSED,
+		machine_mode reload_mode ATTRIBUTE_UNUSED)
+{
+	return GENERAL_REGS;
+}
+#undef	TARGET_SPILL_CLASS
+#define	TARGET_SPILL_CLASS			dd_spill_class
+
 /* XXX gccint 18.9 Node: Stack Layout and Calling Conventions */
 
 /* XXX gccint 18.9.1 Node: Basic Stack Layout */
@@ -509,7 +517,12 @@ static void dd_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)
    instruction.  */
 int dadao_constant_address_p (rtx x)
 {
-  RTX_CODE code = GET_CODE (x);
+	rtx inner;
+
+	if (GET_CODE(x) == SUBREG)
+		inner = SUBREG_REG(x);
+	else	inner = x;
+  RTX_CODE code = GET_CODE (inner);
   int addend = 0;
   /* When using "base addresses", anything constant goes.  */
   int constant_ok = 0;
@@ -526,24 +539,24 @@ int dadao_constant_address_p (rtx x)
       return constant_ok;
 
     case CONST_INT:
-      addend = INTVAL (x);
+      addend = INTVAL (inner);
       break;
 
     case CONST_DOUBLE:
-      if (GET_MODE (x) != VOIDmode)
+      if (GET_MODE (inner) != VOIDmode)
 	/* Strange that we got here.  FIXME: Check if we do.  */
 	return constant_ok;
-      addend = CONST_DOUBLE_LOW (x);
+      addend = CONST_DOUBLE_LOW (inner);
       break;
 
     case CONST:
       /* Note that expressions with arithmetic on forward references don't
 	 work in dadaoal.  People using gcc assembly code with dadaoal might
 	 need to move arrays and such to before the point of use.  */
-      if (GET_CODE (XEXP (x, 0)) == PLUS)
+      if (GET_CODE (XEXP (inner, 0)) == PLUS)
 	{
-	  rtx x0 = XEXP (XEXP (x, 0), 0);
-	  rtx x1 = XEXP (XEXP (x, 0), 1);
+	  rtx x0 = XEXP (XEXP (inner, 0), 0);
+	  rtx x1 = XEXP (XEXP (inner, 0), 1);
 
 	  if ((GET_CODE (x0) == SYMBOL_REF
 	       || GET_CODE (x0) == LABEL_REF)
@@ -569,20 +582,26 @@ int dadao_constant_address_p (rtx x)
 static bool dd_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
 			   rtx x, bool strict_checking)
 {
+	rtx inner;
+
+	if (GET_CODE(x) == SUBREG)
+		inner = SUBREG_REG(x);
+	else	inner = x;
+
 #define	_DD_LEGITIMATE_ADDR_RC(X, XC)	( REG_P(X) &&				\
 	( (REGNO_REG_CLASS(REGNO(X)) == XC) ||					\
 	( !strict_checking && (REGNO (X) >= FIRST_PSEUDO_REGISTER)) ||		\
 	( strict_checking && (REGNO_REG_CLASS(reg_renumber[REGNO(X)]) == XC))))
 
 	/* (mem rp) */
-	if (_DD_LEGITIMATE_ADDR_RC(x, POINTER_REGS))
+	if (_DD_LEGITIMATE_ADDR_RC(inner, POINTER_REGS))
 		return 1;
 
-	if (GET_CODE(x) != PLUS)
+	if (GET_CODE(inner) != PLUS)
 		return 0;
 
-	rtx x1 = XEXP (x, 0);
-	rtx x2 = XEXP (x, 1);
+	rtx x1 = XEXP (inner, 0);
+	rtx x2 = XEXP (inner, 1);
 
 	/* (mem (plus (rp) (rg))) */
 	if (_DD_LEGITIMATE_ADDR_RC(x1, POINTER_REGS) && _DD_LEGITIMATE_ADDR_RC(x2, GENERAL_REGS))
@@ -606,7 +625,13 @@ static bool dd_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
 /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */
 static bool dd_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)
 {
-  RTX_CODE code = GET_CODE (x);
+	rtx inner;
+
+	if (GET_CODE(x) == SUBREG)
+		inner = SUBREG_REG(x);
+	else	inner = x;
+
+  RTX_CODE code = GET_CODE (inner);
 
   /* We must allow any number due to the way the cse passes works; if we
      do not allow any number here, general_operand will fail, and insns
@@ -614,7 +639,7 @@ static bool dd_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)
   if (code == CONST_INT || code == CONST_DOUBLE)
     return 1;
 
-  return CONSTANT_ADDRESS_P (x);
+  return CONSTANT_ADDRESS_P (inner);
 }
 
 #undef	TARGET_LEGITIMATE_CONSTANT_P
@@ -732,6 +757,9 @@ static void dd_encode_section_info (tree decl, rtx rtl, int first)
 #undef	TARGET_ASM_ALIGNED_DI_OP
 #define	TARGET_ASM_ALIGNED_DI_OP		"\t.dd.o64\t"
 
+#undef	TARGET_ASM_UNALIGNED_PDI_OP
+#define	TARGET_ASM_UNALIGNED_PDI_OP		"\t.dd.o64\t"
+
 /* XXX gccint 18.20.3 Node: Output of Uninitialized Variables */
 /* (empty) */
 
diff --git a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.h b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.h
index 6ef87af..e90f459 100644
--- a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.h
+++ b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.h
@@ -45,6 +45,8 @@ struct GTY(()) machine_function
    int in_prologue;
  };
 
+#define	DWARF2_ADDR_SIZE			8
+
 /* For these target macros, there is no generic documentation here.  You
    should read `Using and Porting GCC' for that.  Only comments specific
    to the DADAO target are here.
@@ -100,6 +102,8 @@ struct GTY(()) machine_function
 #define	FLOAT_WORDS_BIG_ENDIAN		1
 #define	UNITS_PER_WORD			8
 
+#define	POINTER_SIZE			48	/* the same as PDImode size */
+
 #define	PARM_BOUNDARY			64
 #define	STACK_BOUNDARY			64
 #define	FUNCTION_BOUNDARY		32
@@ -516,7 +520,7 @@ typedef struct { int regs; int lib; }		CUMULATIVE_ARGS;
 /* ??? DADAO allows a choice of STORE_FLAG_VALUE.  Revisit later,
    we don't have scc expanders yet.  */
 
-#define	Pmode					DImode
+#define	Pmode					PDImode
 #define	FUNCTION_MODE				SImode
 
 #endif /* GCC_DADAO_H */
diff --git a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.md b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.md
index 8bf011b..079e654 100644
--- a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.md
+++ b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/dadao.md
@@ -39,18 +39,15 @@
 
 ;; TODO: are there rp2rf, rf2rv, rv2rs, ... requirements?
 (define_insn "mov<mode>"
-  [(set (match_operand:QHSD 0 "register_operand" "= Rg, Rp, Rf, Rv, Rp, Rf, Rv, Rg, Rg, Rg")
-        (match_operand:QHSD 1 "register_operand" "  Rg, Rp, Rf, Rv, Rg, Rg, Rg, Rp, Rf, Rv"))]
+  [(set (match_operand:QHSD 0 "register_operand" "= Rg, Rf, Rv, Rf, Rv, Rg, Rg")
+        (match_operand:QHSD 1 "register_operand" "  Rg, Rf, Rv, Rg, Rg, Rf, Rv"))]
 	""
 	"@
 	or	%0, %1, 0
-	rp_p2p	%0, %1
 	fo_2fo	%0, %1
 	rv_v2v	%0, %1
-	rp_g2p	%0, %1
 	fo_g2f	%0, %1
 	rv_g2v	%0, %1
-	rp_p2g	%0, %1
 	fo_f2g	%0, %1
 	rv_v2g	%0, %1")
 
diff --git a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/iterators.md b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/iterators.md
index 1315e0a..df63233 100644
--- a/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/iterators.md
+++ b/TCH-gcc/gcc-0903-newfiles/gcc/config/dadao/iterators.md
@@ -10,6 +10,8 @@
 (define_mode_iterator	SFDF		[SF DF])
 (define_mode_attr	ftfo		[(SF "ft") (DF "fo")])
 
+(define_mode_iterator	DIPI		[DI PDI])
+
 (define_code_iterator	RG_ARITH	[and ior xor])
 (define_code_attr	rg_arith_insn	[(and "and") (ior "or") (xor "xor")])
 
